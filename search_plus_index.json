{"./":{"url":"./","title":"Introduction","keywords":"","body":"个人博客 ®专注Cloud NativeCopyright © 李坚才个人博客 All Right Reserved, Powered By LeejiancaiModified At 2020-12-08 21:34:27 "},"云原生模式实践.html":{"url":"云原生模式实践.html","title":"云原生模式实践","keywords":"","body":"1. 云原生软件的各种模式 请求响应模式—这种通信模式可以是同步的，也可以是异步的，通常基于HTTP完成 事件驱动模式—一种分布式系统各个实体之间进行事件通信的协议 CQRS（Command Query Responsibility Segregation， 命令查询职责分离）模式—对某个实体的查询（读）和命令（写）分开处理 多服务实例模式—部署多个实例保证弹性、可伸缩性 水平伸缩模式—创建额外的实例增加服务容量 无状态服务模式—服务不会被后续的服务调用，在内部或本地磁盘中不存储任何状态 有状态服务模式—指用来持久化状态的服务，如消息队列和数据库。这些服务用来为无状态服务提供持久化数据 通过环境变量配置应用程序的模式—应用的配置通过环境变量注入 配置服务模式—这是一个（有状态）服务，用来将配置参数传递给多个应用程序的实例，保证配置一致性 配置即代码模式—对配置文件进行版本控制进行管理 零停机时间升级模式—一种让服务升级时，仍然能够提供完整功能的方法 滚动更新模式—一种通过分批次、增量式升级部分服务，来实现零停机时间升级的技术 蓝/绿升级—一种通过部署一组新的应用，然后全部切换到这些实例来升级的技术 应用程序健康检查—实现一个可以被调用的断点，来访问某个应用程序的健康情况 活性探测—周期调用程序健康断点，如果健康检查失败，则重建对应的实例 服务端负载均衡—一种将请求在多个应用程序之间路由的方法，使得客户端只需向一个单独（LB）实体发送请求 客户端负载均衡—一种将请求在多个应用程序之间路由的方法，客户端知道并且可以控制路由到某个服务的多个实例 服务发现—客户端可以发现它调用的服务的一个或多个地址 重试—请求失败时，重复发起一次请求 安全服务—一个服务无论被调用零次或多次，返回的结果都是一样 幂等服务—一个服务无论被调用一次或多次，返回的结果都是一样 回调— 发完下游的请求无法生成一个结果时，执行的应用程序逻辑 断路器— 一种用来阻止不断向某个故障服务实例发送请求，并且实例恢复后允许继续发送请求的技术 API网关—一种具有访问控制、审计和路由的服务代理 Sidecar（边车）—一种服务代理方法，代理服务本身和服务部署在一起 服务网格—多个Sidecar的网络和控制台 分布式追踪—一种为了跟踪问题原因，用一个线程来跟踪一系列相关分布式服务的方法 事件溯源—一种将事件日志作为软件的真实来源，并且通过物化视图来满足服务实例需求的模式 2. Q&A Q1：云原生软件的设计目的是什么？ A1： 目的是预测故障，并且及时当它所依赖的基础设施发生故障或者发生变化时，它依然能够保持稳定的运行。 Q2：云原生软件核心特征是什么？ A2：高度分布式，运行在在不断变化的环境中，并且软件本身也在不断地发展、变化。 Q3：什么是云原生软件？ A3: 包括如下三种模式的软件开发、部署的模式才能称为云原生软件：云原生应用程序、云原生数据和云原生交互。 云原生应用程序可以进行水平扩容或索容，能够在不稳定的环境中保持弹性，一旦某个实例发生故障，可以快速从集群中隔离。云原生的数据管理需要打破数据统一管理的观念，数据可以是分布式的，并且数据可以来自多种实例（要解决同步的问题），其中缓存是云原生数据模式的一种关键的技术和模式，最终分布式数据结构的核心就是将状态作为一系列事件的结果来处理。云原生交互是解决服务的组合问题，模块化是云原生交互的基础，一个单体拆分为多个服务，服务间通过请求/响应模式或事件分发模式进行通信，并且服务间的通信一定要有重试的机制。 ®专注Cloud NativeCopyright © 李坚才个人博客 All Right Reserved, Powered By LeejiancaiModified At 2020-12-08 23:23:10 "},"C++/虚函数.html":{"url":"C++/虚函数.html","title":"C++虚函数","keywords":"","body":" [TOC] 问题1: 虚构函数是否有必要定义为虚函数？ 先查看一个父类的析构函数不是虚函数，并且用父类的指针指向了子类。 #include class A { public: ~A() { std::cout 输出： ~A() destructor called 可以看到，B的析构函数没有被调用。这样会导致B的资源会泄漏，比如B在初始化的时候打开了一个文件，需要在B的析构函数中Close掉这个文件，但是由于我们使用了父类A指针指向了B的对象，导致了资源泄漏。 如果把A的析构函数定义为虚函数，就不会出现此问题了。修改后的代码为： #include class A { public: virtual ~A() { std::cout 输出： ~B() destructor called ~A() destructor called 总结： 如果有需要用到父类指针引用子类这种多态的功能，需要把父类的析构函数定位为虚函数，避免资源泄漏 如果实在不想把父类的析构函数定义为虚函数，那么就把父类的虚构函数可见范围定位protected，并且不是虚函数，如 #include class A { protected: ~A() { std::cout 编译的时候就会报错如下： virtualDestructor.cc: In function ‘int main(int, char**)’: virtualDestructor.cc:15:10: error: ‘A::~A()’ is protected within this context delete b; ^ virtualDestructor.cc:5:3: note: declared protected here ~A() { std::cout 问题2: 虚函数到底有什么用？ 虚函数解决的运行时多态的问题，所谓的多态就是：运行哪个类的方法。 例子： #include class A { public: virtual void fly(){}; }; class B : public A { public: void fly() { std::cout fly(); c->fly(); delete b; delete c; return 0; } 运行输出： B's fly() called C's fly() called B和C都是继承于A的。因此，实例化B和C后，使用A的指针引用它们，调用fly方法的时候，还是调用的是原来类B或C的fly方法。这种机制就叫多态。面向对象中，除了多态还有重载，刚刚我们说多态是运行时决定运行哪个类的方法，那么在C++中重载就是编译时决定链接某个类的哪个方法。（重载在编译时决定，其实是语言实现机制的问题，single dispatch的语言，重载是在编译是决定的。而double dispatch的语言，多态和重载都是运行时决定的） 重载：类中一个方法的参数不一样，但是函数名字一样。调用哪个方法，是在编译时候决定的。 #include class A { public: virtual void fly(){}; virtual void fly(int){}; }; class B : public A { public: void fly() { std::cout fly(10); c->fly(10); delete b; delete c; return 0; } 输出： B's fly(int) called C's fly(int) called 问题3: ®专注Cloud NativeCopyright © 李坚才个人博客 All Right Reserved, Powered By LeejiancaiModified At 2020-12-21 21:17:25 "}}